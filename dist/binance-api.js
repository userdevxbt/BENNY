/**
 * SHDWXBT - binance-api.js
 * Copyright (c) 2024-2026 SHDWXBT. All rights reserved.
 * 
 * PROPRIETARY AND CONFIDENTIAL
 * Unauthorized copying, modification, distribution, or use is strictly prohibited.
 * This code is protected by intellectual property laws.
 * 
 * Build: 2026-01-28T12:08:11.848Z
 * Checksum: SHDW-4D6A130C
 */
const BinanceAPI={config:{baseUrl:"https://fapi.binance.com/fapi/v1",wsUrl:"wss://fstream.binance.com/ws",wsCombinedUrl:"wss://fstream.binance.com/stream?streams=",maxRequestsPerMinute:1200,requestWeight:{ticker:1,klines:1,ticker24hr:1},cacheTTL:{ticker:5e3,klines:6e4,ticker24hr:3e4}},state:{requestCount:0,requestWindowStart:Date.now(),cache:new Map,wsConnections:new Map,tickers:new Map,subscribedSymbols:new Set,tickerCallback:null,isConnected:!1,lastError:null},async checkRateLimit(t=1){const e=Date.now();if(e-this.state.requestWindowStart>6e4&&(this.state.requestCount=0,this.state.requestWindowStart=e),this.state.requestCount+t>this.config.maxRequestsPerMinute){const t=6e4-(e-this.state.requestWindowStart);console.warn(`â³ Rate limit approaching, waiting ${t}ms...`),await new Promise(e=>setTimeout(e,t+100)),this.state.requestCount=0,this.state.requestWindowStart=Date.now()}this.state.requestCount+=t},getCached(t){const e=this.state.cache.get(t);return e?Date.now()-e.timestamp>e.ttl?(this.state.cache.delete(t),null):e.data:null},setCache(t,e,s){this.state.cache.set(t,{data:e,timestamp:Date.now(),ttl:s})},async request(t,e={},s=1){const a=`${t}:${JSON.stringify(e)}`,i=this.getCached(a);if(i)return i;await this.checkRateLimit(s);try{const s=new URL(this.config.baseUrl+t);Object.entries(e).forEach(([t,e])=>s.searchParams.append(t,e));const i=await fetch(s.toString());if(!i.ok){if(429===i.status)return console.warn("âš ï¸ Rate limited by Binance, using cache/fallback"),this.state.lastError="rate_limited",null;throw new Error(`HTTP ${i.status}`)}const r=await i.json();let o=this.config.cacheTTL.ticker;return t.includes("klines")&&(o=this.config.cacheTTL.klines),t.includes("24hr")&&(o=this.config.cacheTTL.ticker24hr),this.setCache(a,r,o),this.state.isConnected=!0,r}catch(t){return console.error("Binance API Error:",t.message),this.state.lastError=t.message,null}},async getTicker(t){const e=await this.request("/ticker/price",{symbol:t},1);return e?(this.state.tickers.set(t,{symbol:t,price:parseFloat(e.price),lastPrice:parseFloat(e.price),timestamp:Date.now()}),this.state.tickers.get(t)):this.getSimulatedTicker(t)},async getTicker24hr(t){const e=await this.request("/ticker/24hr",{symbol:t},40);if(!e)return this.getSimulatedTicker(t);const s={symbol:e.symbol,price:parseFloat(e.lastPrice),lastPrice:parseFloat(e.lastPrice),price24hPcnt:parseFloat(e.priceChangePercent),volume24h:parseFloat(e.quoteVolume),high24h:parseFloat(e.highPrice),low24h:parseFloat(e.lowPrice),timestamp:Date.now()};return this.state.tickers.set(t,s),s},async getAllTickers(){const t=await this.request("/ticker/price",{},2);return t?(t.forEach(t=>{this.state.tickers.set(t.symbol,{symbol:t.symbol,price:parseFloat(t.price),lastPrice:parseFloat(t.price),timestamp:Date.now()})}),t):[]},async getKlines(t,e,s=200){const a={1:"1m",3:"3m",5:"5m",15:"15m",30:"30m",60:"1h",120:"2h",240:"4h",360:"6h",720:"12h",D:"1d",W:"1w",M:"1M"}[e]||e,i=await this.request("/klines",{symbol:t,interval:a,limit:s},1);return i&&Array.isArray(i)?i.map(t=>({timestamp:t[0],open:parseFloat(t[1]),high:parseFloat(t[2]),low:parseFloat(t[3]),close:parseFloat(t[4]),volume:parseFloat(t[5]),closeTime:t[6]})):this.generateSimulatedKlines(t,s,e)},getCachedTicker(t){return this.state.tickers.get(t)||null},subscribeToTicker(t,e){Array.isArray(t)||(t=[t]);const s=t.map(t=>t.toUpperCase());this.state.tickerCallback=e,this.state.subscribedSymbols=new Set(s);for(const[t,e]of this.state.wsConnections.entries())if(t.startsWith("tickers")&&e&&e.readyState!==WebSocket.CLOSED)try{e.close()}catch{}const a=[];for(let t=0;t<s.length;t+=90)a.push(s.slice(t,t+90));a.forEach((t,s)=>{const i=t.map(t=>`${t.toLowerCase()}@ticker`).join("/"),r=`${this.config.wsCombinedUrl}${i}`;try{const i=new WebSocket(r);i.onopen=()=>{console.log(`ðŸ”— Binance WebSocket connected [chunk ${s+1}/${a.length}] (${t.length} symbols)`),this.state.isConnected=!0},i.onmessage=t=>{try{const s=JSON.parse(t.data),a=s?.data||s;if(!a?.s)return;const i={symbol:a.s,price:parseFloat(a.c),lastPrice:parseFloat(a.c),price24hPcnt:parseFloat(a.P),volume24h:parseFloat(a.q),timestamp:Date.now()};this.state.tickers.set(a.s,i),e&&e(i)}catch(t){}},i.onerror=t=>{console.warn("WebSocket error:",t)},i.onclose=()=>{console.log(`WebSocket chunk ${s+1} disconnected, reconnecting in 5s...`),this.state.isConnected=!1,setTimeout(()=>{if(this.state.subscribedSymbols&&this.state.subscribedSymbols.size>0){const t=Array.from(this.state.subscribedSymbols);this.subscribeToTicker(t,this.state.tickerCallback)}},5e3)},this.state.wsConnections.set(`tickers_${s}`,i)}catch(t){console.error("WebSocket connection failed:",t)}})},addSymbolsToTicker(t){Array.isArray(t)||(t=[t]);t.map(t=>t.toUpperCase()).forEach(t=>this.state.subscribedSymbols.add(t));const e=Array.from(this.state.subscribedSymbols);this.subscribeToTicker(e,this.state.tickerCallback)},subscribeToKlines(t,e,s){const a={1:"1m",5:"5m",15:"15m",60:"1h",240:"4h",D:"1d",W:"1w"}[e]||"1h",i=`${this.config.wsUrl}/${t.toLowerCase()}@kline_${a}`;try{const a=new WebSocket(i);a.onmessage=t=>{try{const e=JSON.parse(t.data).k,a={timestamp:e.t,open:parseFloat(e.o),high:parseFloat(e.h),low:parseFloat(e.l),close:parseFloat(e.c),volume:parseFloat(e.v),isClosed:e.x};s&&s(a)}catch(t){}},this.state.wsConnections.set(`klines_${t}_${e}`,a)}catch(t){console.error("Klines WebSocket failed:",t)}},getSimulatedTicker(t){const e=this.getBasePrice(t),s=.02*(Math.random()-.5);return{symbol:t,price:e*(1+s),lastPrice:e*(1+s),price24hPcnt:10*(Math.random()-.5),volume24h:1e8*Math.random(),timestamp:Date.now()}},generateSimulatedKlines(t,e,s){const a=[];let i=this.getBasePrice(t)*(1+.1*(Math.random()-.5));const r={1:1,5:5,15:15,60:60,240:240,D:1440,W:10080,M:43200}[s]||60;for(let t=0;t<e;t++){const s=i,o=i+(Math.random()-.5)*i*.015,c=Math.max(s,o)*(1+.008*Math.random()),n=Math.min(s,o)*(1-.008*Math.random());a.push({timestamp:Date.now()-(e-t)*r*6e4,open:s,high:c,low:n,close:o,volume:1e6*Math.random()}),i=o}return a},getBasePrice:t=>({BTCUSDT:1e5,ETHUSDT:3200,BNBUSDT:700,SOLUSDT:200,XRPUSDT:2.5,ADAUSDT:1,DOGEUSDT:.35,AVAXUSDT:40,LINKUSDT:25,DOTUSDT:8,MATICUSDT:.5,LTCUSDT:120}[t]||100*Math.random()+1),async getBatchKlines(t,e,s=200){const a={};for(let i=0;i<t.length;i+=5){const r=t.slice(i,i+5).map(t=>this.getKlines(t,e,s).then(e=>({symbol:t,data:e})).catch(()=>({symbol:t,data:this.generateSimulatedKlines(t,s,e)})));(await Promise.all(r)).forEach(t=>{a[t.symbol]=t.data}),i+5<t.length&&await new Promise(t=>setTimeout(t,200))}return a},async getSymbolData(t){const[e,s,a,i]=await Promise.all([this.getTicker24hr(t),this.getKlines(t,"60",200),this.getKlines(t,"240",200),this.getKlines(t,"D",200)]);return{symbol:t,ticker:e,klines:{60:s,240:a,D:i}}},getStatus(){return{isConnected:this.state.isConnected,requestCount:this.state.requestCount,cacheSize:this.state.cache.size,tickersCount:this.state.tickers.size,lastError:this.state.lastError}}};"undefined"!=typeof window&&(window.BinanceAPI=BinanceAPI);